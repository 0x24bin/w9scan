#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author: w8ay
# @Date:   2017年12月19日 12:04:55
import os
from lib.core.data import paths
import imp
from lib.core.log import *
from thirdparty import miniCurl
from lib.utils import until
from lib.core.data import urlconfig
from thirdparty import hackhttp
from thirdparty.ThreadPool import ThreadPool
import threading
import traceback,time

class Exploit_run(object):

    def __init__(self,threadNum = 20):
        self.hash_pycode_Lists = {}
        filter_func = lambda file: (True, False)['__init__' in file or 'pyc' in file]
        dir_exploit = filter(filter_func, os.listdir(paths.w9scan_Plugin_Path))

        self._TargetScanAnge = {'target': urlconfig.url,
                                'scanport': urlconfig.scanport}

        try:
            for exp in dir_exploit:
                with open(os.path.join(paths.w9scan_Plugin_Path,exp), 'rb') as f:
                    reads = str(f.read())
                    f.close()
                    self.hash_pycode_Lists.setdefault(exp, reads)
        except Exception as error_info:
            self._print(error_info)
            self._print('[***] Fetch %d new plugins' % len(self.hash_pycode_Lists))
        
        self.threadNum = threadNum
        self.outputLock = threading.Lock()
        self.ThreadPool = ThreadPool(self.threadNum)
        self._print('[***] Set the number of concurrent: %d'%(threadNum))


    def _load_module(self,chunk,name='<w9scan>'):
        pluginObj = imp.new_module(str(name))
        exec chunk in pluginObj.__dict__
        return pluginObj
    
    def load_modules(self,service,url):
        # 内部载入所有模块，并且判断服务名是否正确
        
        for k, v in self.hash_pycode_Lists.iteritems():
            pluginObj = self._load_module(v)
            pluginObj.task_push = self.task_push
            pluginObj.curl = miniCurl.Curl()
            pluginObj.security_note = self._security_note
            pluginObj.security_info = self._security_info
            pluginObj.security_warning = self._security_warning
            pluginObj.security_hole = self._security_hole
            pluginObj.debug = self._debug
            pluginObj.util = until
            pluginObj._G = self._TargetScanAnge
            pluginObj.hackhttp = hackhttp.hackhttp()

            threadConf = dict()
            threadConf["filename"] = k
            threadConf["service"] = service
            threadConf["url"] = url
            self.ThreadPool.add_task(self._work,pluginObj,threadConf)


    def _work(self,pluginObj,threadConf):
        # 程序内部工作线程
        try:

            pluginObj_tuple = pluginObj.assign(threadConf["service"], threadConf["url"])

            if not isinstance(pluginObj_tuple, tuple):  # 判断是否是元组
                return
            bool_value, agrs = pluginObj_tuple[0], pluginObj_tuple[1]

            if (bool_value):
                self._print( "[***] Load plugin %s for service '%s'" % (threadConf["filename"], threadConf["service"]))
                pluginObj.audit(agrs)
        except Exception as error_info:
            self._print( "[!!!] ",threadConf["service"], threadConf["filename"],error_info)
    
    def wait(self):
        while self.ThreadPool.wait():
            time.sleep(1)

    def _security_note(self, body, uuid=None):
        self.outputLock.acquire()
        logger.security_note(body)
        self.outputLock.release()

    def _security_info(self, body, uuid=None):
        self.outputLock.acquire()
        logger.security_info(body)
        self.outputLock.release()

    def _security_warning(self, body, uuid=None):
        self.outputLock.acquire()
        logger.security_warning(body)
        self.outputLock.release()

    def _security_hole(self, body, uuid=None):
        self.outputLock.acquire()
        logger.security_hole(body)
        self.outputLock.release()

    def _debug(self, fmt, *args):
        if len(args) >= 3:
            self._print( "[debug] < ", fmt % args, " >")

    def task_push(self, serviceType, target_info, uuid=None, target=None, pr=-1):
        self.load_modules(serviceType,target_info)

    def _print(self,*args):
        self.outputLock.acquire()
        print(''.join(args))
        self.outputLock.release()